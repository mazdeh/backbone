{"name":"Backbone","tagline":"An introduction to Backbone.js.","body":"# An Introduction to Backbone.js\r\n\r\nRich client-side web applications struggle to keep data in sync between the HTML UI, Javascript logic, and server-side database. \r\n\r\nMore often that not, web developers find themselves stuck with piles of jQuery selectors tying the data to the DOM, which in turn, negatively affects performance and overall UX of the WebApp.\r\n\r\nBackbone offers a more structured approach to this problem by separating the logic, data, and UI of applications.\r\n\r\n# Backbone Terminology — MVC\r\n\r\nBackbone has 3 components:\r\n*Models\r\n*Views\r\n*Collections — not controller.\r\n\r\n### 1. Models\r\n  * Handle data and business logic.\r\n  * Load and save from the server.\r\n  * Fire events upon data change.\r\n\r\n   Whenever a UI action causes an attribute of a model to change, the model triggers a ‘change’ event; the **Views** that are watching the state of the model can then be notified of the change, and update themselves accordingly. This eliminates the need to access DOM elements by specific _id_’s, and having to manually change the HTML.\r\n\r\n> A **Model** manages an internal table of data attributes, and triggers “change” events when any of its data is modified. Models handle syncing data with a persistence layer — usually a REST API with a backing database.\r\n\r\nA good model is one that is re-useable, easily passed around in the code, and a comprehensive representation of the data it is referencing.\r\n\r\n### 2. Views\r\n  * Listen for changes, and render UI.\r\n  * Handle user input and interactivity.\r\n  * Send input to model.\r\n\r\n> A View is an atomic chunk of user interface. It often renders the data from a specific model, or number of models — but views can also be data-less chunks of UI that stand alone. Models should be generally unaware of views. Instead, views listen to the model \"change\" events, and react or re-render themselves appropriately.\r\n\r\n\r\n### 3. Collections\r\n> A **Collection** helps you deal with a group of related models, handling the loading and saving of new models to the server and providing helper functions for performing aggregations or computations against a list of models. Aside from their own events, collections also proxy through all of the events that occur to models within them, allowing you to listen in one place for any change that might happen to any model in the collection.\r\n\r\n# Example Site\r\nIn this presentation, I will be building a simple single-page web application with *Backbone.js* to better demonstrate the capabilities of this framework. \r\nTo make the example more interesting, and to avoid the complexities of implementing the server-side, I am going to be using an API instead — Thomas Davis's API. In a later tutorial, I will replace this API with one that we will write together using `express.js` — another great JS library, to introduce some server-side excitement to this project.\r\n\r\n\r\n#### Set up!\r\nCreate an `index.html` file, and include Backbone and its dependancies:\r\n1. jQuery\r\n2. Underscore\r\n\r\nUnderscore is a great library of amazing, helpful functions. I will cover Underscore in another tutorial later on, but make sure to include it in your `index.html`, or you won't be able to follow along with the example site. \r\n\r\nLet’s get started!\r\n\r\n#### Backbone.Router\r\nBackbone is great for single page web applications. The Router watches the URL of your website and allows you to update your site based on the url. Router will also watch for back clicks on the browses, and updates accordingly.\r\n\r\nNow, in a `<script>` tag in your `index.html` file, set you home page to be the landing page of your website, like below:\r\n\r\n```javascript\r\nvar Router = Backbone.Router.extend({\r\n    routes: {\r\n      \"\": \"home\"\r\n    }\r\n  });\r\n```\r\n\r\nThen, we can instantiate a new Router for our site, by doing:\r\n```javascript\r\nvar router = new Router();\r\n```\r\n\r\nThe Backbone Router class, emits an event called `route`, so we can use jQuery to listen to this event.\r\nNow, `console.log()` and watch your console on the browser, to make sure you router is working properly.\r\n```javascript\r\nrouter.on('route:home', function () {\r\n\tconsole.log('We're on the Homepage!);\r\n});\r\n```\r\n_note: The Router starts watching for changes only after you run `Backbone.history.start()`. So make sure you have this line towards the end of your `<script>` tag._\r\n\r\n\r\n#### Backbone.View\r\nNow let's create a Backbone view.\r\nEach view has a `render` function that is in charge of rendering the view element.\r\nKeep in mind, that a view shall not reach for anything outside of its own scope. A view is an atomic chunk of UI.\r\n\r\nHere's the syntax:\r\n```javascript\r\nvar UserListView = Backbone.View.extend({\r\n\tel: '.page',\r\n\trender: function () {\r\n\t\tthis.$el.html('content here');\r\n\t}\r\n});\r\n```\r\nWe pass in the DOM element to the view, through the View’s  `el` attribute. Then we can access the specific element inside the view by `this.$el`.\r\n\r\n_note: Make sure you have a div with class name `page` in your html. That is where the Backbone.View will be rendering itself!_\r\n\r\nNow we need to instantiate the view we just created, and render it on our home page.\r\n\r\n```javascript\r\nvar userListView = new UserListView();\r\n```\r\n\r\nThen, we can ask Router to render the userListView for us, on the homepage, by calling userListView’s `render()` function.\r\n```javascript\r\nrouter.on('route:home', function () {\r\n\tuserListView.render();\r\n})\r\n```\r\nAnd that is the basics of how you create a view and render it in the HTML.\r\n\r\n#### Backbone.Collection\r\nCollections keep our data. So to populate our users view, we are going to create a Backbone.Collection, and point its `url` to a resource endpoint. The Collection will pull from that `url` and store that data.\r\n\r\n_note: you need to define the `base url` of your resource endpoint in an ajaxPrefilter function._\r\n\r\n```js\r\nvar Users = Backbone.Collection.extend({\r\n    url: ‘/users'\r\n});\r\n```\r\nGo ahead and instantiate the Users Collection, inside your userListView’s `render()` function.\r\n```js\r\nvar users = new Users();\r\n```\r\n\r\nNow we need to fetch down the data from the `/users` datasource to populate the users instance of this collection.\r\n\r\n_note: `fetch()` is one of the many Underscore methods that Backbone utilizes. I will be adding more information about Underscore later on. For now, you can just copy the code from `index.html`, where you see `underscore` comments.\r\n\r\n_note: that in fetch's callback function, we do *not* have access to `this`. Hence we need to pass the scope down to the success function by doing:_\r\n```js\r\nvar that = this;\r\n```\r\nand then use `that` inside the success callback.\r\n\r\n```js\r\nusers.fetch({\r\n\tsuccess: function() {\r\n\t\tthat.$el.html('data came down!');\r\n\t}\r\n});\r\n```\r\n\r\nRefresh the page, check the *network* tab in your Chrome Dev Tools, and you will see that the data has been successfully fetched!\r\n\r\nThis concludes our very brief discussion of how to use a RESTful API with Backbone's Router, in addition to Backbone's Views and Collections to fetch data from a server and render it in the html.\r\n\r\nIt should be clear to a somewhat experienced web developer how Backbone's structured approach in separating data and logic from the UI, is making things much easier, and smooth.\r\n\r\n---\r\nNext we're going to introduce Backbone Models, and show you how they can make your lives easier, as web dev's.\r\n\r\nWhat we've done so far is we've handled a response from a `GET` request from the server. We've parsed the data through our *Collection* class and rendered it using a *View*.\r\n\r\nNow, we are going to see how we can use Routers and Models to do some other HTTP requests (i.e POST, PUT, DELETE).\r\n\r\n_note: to be able to continue on using Thomas's server, we are going to implement a simple add/edit user functionality to the current state of our app. This will however change as we move onto implementing our own server, using `express.js`._\r\n\r\n\r\nMake a button somewhere inside the Underscore template (`user-list-template`). The `href` should point to `#/new`.\r\n\r\nWe're using a `#` because this is a single-page application, we do not want to navigate to a different page. Backbone removes the hashtag from the URL. \r\n\r\nNow we need to let the Router know that we have another URL that it should be watching for. So let's go ahead and add that to the Router class:\r\n\r\n```js\r\nvar Router = Backbone.Router.extend({\r\n    routes: {\r\n      \"\": \"home\",\r\n      \"new\": \"editUser\"\r\n    }\r\n});\r\n```\r\nAnd tell the router to do the right thing, when it observes the `/new` URL.\r\n```js\r\nrouter.on('route:editUser', function() {\r\n  console.log('I know what do, when New is clicked.');\r\n});\r\n```\r\nSo, as you may have guessed, we need a new View here, so that when the New button is clicked we show the user and appropriate view, where they can add their user information. So let's create a Backbone View that does just that :\r\n```js\r\nvar EditUserView = Backbone.View.extend({\r\n  el: '.page',\r\n  render: function () {\r\n    this.$el.html('We're on /new!');\r\n  }\r\n});\r\n```\r\nNote that we are passing the same `el` to this view, because we would want it to replace the current element of the DOM with the new one that we will be providing it with.\r\n\r\nAs you should have guessed by now, we are going to instantiate the new view, and update our router listener to render the view when it observes the new URL.\r\n\r\nNow let's make that `editUserView` show something more meaningful. Just add a new Underscore template with the `id=\"edit-user-template\"` and update the view so that it populates the `html` with the template you just created. In you template, it would makes sense to have some sort of a form, where you'd ask for things like firstname, lastname, and age. You will also need a Submit button, so we can actually do a `POST` to server.\r\n\r\n_note: the templates in this example are all made using Underscore's templating, which I will cover later on! You could however use any templating tool you prefer, like Handlebars, etc._\r\n\r\nThe updated view should look something like this:\r\n```js\r\nvar EditUserView = Backbone.View.extend({\r\n  el: '.page',\r\n  render: function () {\r\n    var template = _.template($('#edit-user-template').html(), { });\r\n    this.$el.html(template);\r\n  }\r\n});\r\n```\r\n\r\nNow if you click on the New button, it should take you to the Create New User page, and show you the form you created in the template.\r\n\r\n##### Backbone Events\r\n\r\nWe need a way to listen to the form's submit button, so that we take the appropriate action to create a new user, when the button is clicked. Backbone Views have a events object, that listens for different events that happen on the specified DOM elements.\r\n\r\nHere's the syntax for how you'd create events inside a Backbone View:\r\n\r\n```js\r\nevents: {\r\n  'event selector': 'action'\r\n}\r\n```\r\n`event` could be any jQuery event (i.e. click, focus, etc.).\r\nWe would like to listen to the submit event of the `.edit-user-template` form, and then we want to fire a function that handles a `POST` to the server. So:\r\n```js\r\nevents: {\r\n  'submit .edit-user-template': 'saveUser'\r\n}\r\n```\r\nThe event passes an `ev` object to `saveUser` that gives us access to that specific event.\r\n\r\nNow that we are listening to this event, let's define our `saveUser` function inside the View.\r\nFist, we need to grab the form elements and turn it into a JSON object. You can find a jQuery `serizlizeObject()` function online that does that for you. \r\n```js\r\nsaveUser: function (ev) {\r\n  var userDetails = $(ev.currentTarget).serializeObject();\r\n}\r\n```\r\nNow that we have a JSON object (model) of the data, let's turn it into a Backbone Model.\r\n\r\n#### Backbone.Model\r\nModels are the units in a Collection. So where the Collection is an array of object (models), the Model is the actual object. So we are going to call the Model `User` rather than `Users`, that we used for the Collection.\r\n\r\nThe syntax that should look familiar to you by now:\r\n```js\r\nvar User = Backbone.Model.extend({\r\n    urlRoot: '/users'\r\n});\r\n```\r\n`urlRoot` is pretty similar to the `url` attribute that you saw in Collections. The Model class however knows how to append to the `urlRoot` based on the request it gets. So if we did a `PUT` requests, it appends the `id` to the end of the `urlRoot`. Similarly for `DELETE`. But if we were to do a `POST` to `/users`, it would know that there doesn't need to be an `id` attached to the `urlRoot`. \r\n\r\nNow that we have a Model, we want the `saveUser` function to save this model to the server for us. So in `saveUser` we add:\r\n```js\r\nvar user = new User(); // instantiate the Model\r\nuser.save(userDetails, {\r\n  success: function() {\r\n    // do something\r\n  }\r\n});\r\nreturn false; // this line is required to finish the request!\r\n```\r\nAs you can see, the `save()` function, takes in as its first argument, the model object, and as its second argument an options hash, where you could tell it what to do upon `success` or `error`. \r\n\r\n`save()` is intelligent enough to know what request to send to the server. So if you check your network tab, after you create a new user, you should see a `POST` request.\r\n\r\nBut what if this user already existed in our database, and we only wanted to do a `PUT` request to update it?\r\nLet's modify our code, just a little bit, to account for that case.\r\n\r\nFirst, you should add an *edit* button to your `edit-user-template`, for each user in the table. We need to include the `id` of the user that we're trying to edit in the `href` of the edit button. So when then Edit button is clicked, our URL should change to something like: `#/edit/user.id`\r\n\r\n_note: Don't worry, passing in the `user.id` via the HTML is Underscore stuff that I will cover later!_\r\n\r\nNow we should update our Router to watch for the `/edit` URL.\r\n```js\r\nvar Router = Backbone.Router.extend({\r\n  routes: {\r\n    \"\": \"home\",\r\n    \"new\": \"editUser\",\r\n    \"edit/:id\": \"editUser\"\r\n  }\r\n});\r\n```\r\n\r\nNotice that the Router will direct both `new` and `edit/:id` to the same editUser's callback. So we need to modify our callback to account for when there's an `id` passed along. This means our `router` instance will have an `id` passed on to it.\r\n```js\r\nrouter.on('route:editUser', function(id) { // id is being passed to the callback function\r\n  editUserView.render(id);\r\n});\r\n```\r\nSo now we can pass that `id` to our `render()` function and modify our `EditUserView` to account for that.\r\nThis is simply done by adding an `options` variable to our `render()` function inside `EditUserView`, and then adding some conditionals to see if `id` is present or not. If we have an `options.id`, we should want to fetch that user from the server and populate the form with that user's info, and if no id is present, we will just have an empty form, so that the a new user's info could be entered.\r\n\r\nHere's how our `render()` function would look like after these changes:\r\n```js\r\nrender: function (options) {\r\n  if (options.id) {\r\n    var user = new User({id: options.id});\r\n    var that = this;\r\n    user.fetch({\r\n      success: function(user) {\r\n        var template = _.template($('#edit-user-template').html(), { user: user });  // pass in the user model\r\n        that.$el.html(template);  // populated form\r\n      }\r\n    })\r\n  } else {\r\n    var template = _.template($('#edit-user-template').html(), { user: null });   // no id present, no user model\r\n    this.$el.html(template);  // empty form\r\n  }\r\n}\r\n```\r\n\r\nNow we need to make sure our form gets populated with the user's data. This is more Underscore stuff that I will be covering later!\r\n\r\nWe are now able to update a user on the server, by sending a `PUT` request. As we already talked about `user.save()` knows what request to send to the server based on if there's an `id` or not.\r\n\r\n---\r\nThis concludes our introduction to Backbone.js. This tutorial was inspired by Thomas Davis's. I will update this project with more information on Underscore, and then I will be creating a server-side component for it, using Express. Stay tuned!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}